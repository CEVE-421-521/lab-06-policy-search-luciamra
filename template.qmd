---
title: "Lab 6: Policy Search"
author: "Lucia Roemro-Alston (lmr12)"
jupyter: julia-1.10
date: 2024-03-01
week: 7
categories: [Lab]

format: 
    html: default

    # YOU DO NOT NEED BOTH PDF AND DOCX.
    # COMMENT OR DELETE THE ONE YOU DON'T WANT TO USE.
    pdf:
        documentclass: article
        fontsize: 11pt
        geometry:
            - margin=1in  
        number-sections: true
        code-line-numbers: true
    #docx: 
    #    toc: true
    #    fig-format: png
    #    number-sections: true
    #    code-line-numbers: true

date-format: "ddd., MMM. D"

execute: 
  cache: true
  freeze: auto

bibliography: references.bib
---

```{julia}
using Revise
using HouseElevation

using CSV
using DataFrames
using DataFramesMeta
using Distributions
using LaTeXStrings
using Metaheuristics
using Plots
using Random
using Unitful

Plots.default(; margin=5Plots.mm)
```

```{julia}
function objective_function(a::AbstractFloat)
    return true # PLACEHOLDER
end
```

## Objective Function

We want to keep the same objective function that we have been using in order to find the net present value taking in the cost of heightening the house and the discounted expected costs of future flood damage. We also consider and define the states of the world over which we will analyze.
The building I am studying is Fisherman's Wharf at 2200 Harborside Drive Galveston, TX.
I got the information for the building area from the cvent website for event space. The value of the property results from searches on Zillow for average building prices in the area. Finally, the depth-damage curve which I chose is a result of location, building type, and what I am looking to analyze for damages. 
```{julia}
slr_scenarios = let
    df = CSV.read("data/slr_oddo.csv", DataFrame)
    [Oddo17SLR(a, b, c, tstar, cstar) for (a, b, c, tstar, cstar) in eachrow(df)]
end

house = let
    haz_fl_dept = CSV.read("data/haz_fl_dept.csv", DataFrame) # read in the file
    desc = "Cafeteria Restaurant, structure"
    row = @rsubset(haz_fl_dept, :Description == desc)[1, :] # select the row I want
    area = 4004u"ft^2"
    height_above_gauge = 4*u"ft"
    House(row; area=area, height_above_gauge=height_above_gauge, value_usd=400_000)
end

p = ModelParams(; house=house, years=2024:2100)

function draw_surge_distribution()
    μ = rand(Normal(5, 1))
    σ = rand(Exponential(1.5))
    ξ = rand(Normal(0.1, 0.05))
    return GeneralizedExtremeValue(μ, σ, ξ)
end
function draw_discount_rate()
    return 0.0
end

N_SOW = 10
sows = [
    SOW(rand(slr_scenarios), draw_surge_distribution(), draw_discount_rate()) for
    _ in 1:N_SOW
] # for 10 SOWs
```

## Validation

We can validate our answer by comparing it to a simple Monte Carlo estimate using 25,000 samples and timing how long this takes us. 
```{julia}
a = Action(3.0u"ft")
sow = first(sows)
_ = run_sim(a, sow, p)
@time run_sim(a, sow, p)
```

```{julia}
_ = HouseElevation.run_sim_old(a, sow, p)
@time HouseElevation.run_sim_old(a, sow, p)
```

## Optomization Problem

We are looking to solve a non-linear, non-convex optomization problem using the Metaheuristics.jl package.
The following plots the dunction we are looking to minimize for D=2.
```{julia}
f(x) = 10length(x) + sum(x .^ 2 - 10cos.(2π * x))
let
    # Generate a grid of points for the surface plot
    x = range(-5; stop=5, length=1000)
    y = range(-5; stop=5, length=1000)
    z = [f([i, j]) for i in x, j in y]

    # Create the surface plot
    surface(
        x, y, z; xlabel="x1", ylabel="x2", zlabel="f(x)", title=L"Minimize $f(x)$ for $D=2$"
    )
end
```

Now, if we want to minimize with D=10, we have to define bounds that constrians the search space to the decision variables.
```{julia}
D = 10
bounds = boxconstraints(; lb=-5ones(D), ub=5ones(D))
```

This can be optomized using the optomize function.
```{julia}
result = optimize(f, bounds)
```

The minimum of the objective function:
```{julia}
minimum(result)
```

The value of the decision variable that achieves the minimum:
```{julia}
minimizer(result)
```

It can be helpful to set constraints and specifications to the optomizer such as time limits, especially for problems that may take very long to run.
```{julia}
options = Options(; time_limit=10.0)
```

 We will use the ECA algorithm which is suggested as default.
 ```{julia}
 algorithm = ECA(; options=options)
 ```

 We will set a random seed to make our results more reproducable and to understand the sensitivity of our results with respect to the random seed.
 ```{julia}
 Random.seed!(918)
result = optimize(f, bounds, algorithm)
```

And check for a different iteration:
```{julia}
Random.seed!(952)
result = optimize(f, bounds, algorithm)
```

## Varying D

We can play around with some of the conditions of the optomization above in order to gain some knowledge on the effects of certian values on the optomization. For example, we can vary D to develop our understanding of this parameter.
```{julia}
function optomization()
    trials = 1:2:19
    for D in trials
        D = rand(trials)
        bounds = boxconstraints(; lb=-5ones(D), ub=5ones(D))
        # Optomization:
        result = optimize(f, bounds)
        # Minimum:
        minimum(result)
        # Value of the decision variable that achieves the minimum:
        minimizer(result)
        # Specifications:
        options = Options(; time_limit=10.0)
        algorithm = ECA(; options=options)
        # Random Seed:
        Random.seed!(918)
        result2 = optimize(f, bounds, algorithm)
    end
end
```



```{julia}
df = DataFrame(
    D = optomization.D,
    results = result,
    minumum = minimum(result),
    minimizer = minimizer(result),
    seed_result = result2
)
```